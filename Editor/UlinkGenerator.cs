#nullable enable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Ulink.Runtime;
using UnityEditor;
using UnityEditor.Compilation;
using UnityEngine;
using UnityEngine.UIElements;

namespace Ulink.Editor
{
    [InitializeOnLoad]
    public static class UlinkGenerator
    {
        private const string GenerateFolder = "Generated/Controller";
        private const string AssetsPath = "Assets";
        private const string UlinkFileName = "Ulink.g.cs";
        private const int TemplateVersion = 1;

        static UlinkGenerator()
        {
            EditorApplication.delayCall += GenerateControllers;
        }

        [MenuItem("Tools/Leo's Tools/Ulink/Generate Controllers")]
        public static void GenerateControllers()
        {
            GenerateControllers(UlinkSettings.instance.TargetFolder);
        }

        public static void GenerateControllers(string targetFolder)
        {
            var uxmlElementTypes = new HashSet<Type>(
                TypeCache.GetTypesWithAttribute<UxmlElementAttribute>());

            var controllerTypes = TypeCache.GetTypesWithAttribute<UlinkAttribute>()
                .Where(type => type.IsClass
                               && !type.IsAbstract
                               && typeof(VisualElement).IsAssignableFrom(type)
                               && uxmlElementTypes.Contains(type))
                .GroupBy(type => type.FullName)
                .Select(group => group.First())
                .ToList();

            controllerTypes = controllerTypes.GroupBy(type => type.FullName).Select(group => group.First()).ToList();
            var options = new HashSet<Type>(controllerTypes);
            controllerTypes = controllerTypes.Where(type => !HasBaseClass(type, options)).ToList();

            var typeLookup = new Dictionary<string, List<Type>>();

            foreach (var type in controllerTypes)
            {
                string? scriptAssetPath = FindScriptAssetPath(type);
                if (string.IsNullOrEmpty(scriptAssetPath))
                {
                    continue;
                }

                string rootPath = GetAssemblyRoot(scriptAssetPath!);
                if (!typeLookup.TryGetValue(rootPath, out var types))
                {
                    types = new List<Type>();
                    typeLookup[rootPath] = types;
                }

                types.Add(type);
            }

            var anyChanged = false;

            foreach ((string? key, var types) in typeLookup)
            {
                if (types.Count == 0)
                {
                    continue;
                }

                string generatedPath = Path.Combine(key, GenerateFolder);

                if (!Directory.Exists(generatedPath))
                {
                    Directory.CreateDirectory(generatedPath);
                }

                string filePath = Path.Combine(generatedPath, UlinkFileName);

                var sorted = types.OrderBy(type => type.Namespace).ThenBy(type => type.Name).ToList();

                string newContent = BuildFileContent(sorted);

                if (File.Exists(filePath))
                {
                    string previousContent = File.ReadAllText(filePath);
                    if (string.Equals(previousContent, newContent, StringComparison.Ordinal))
                    {
                        continue;
                    }
                }

                try
                {
                    string temp = filePath + ".tmp";
                    File.WriteAllText(temp, newContent);
                    if (File.Exists(filePath))
                    {
                        File.Replace(temp, filePath, null);
                    }
                    else
                    {
                        File.Move(temp, filePath);
                    }
                }
                catch (Exception e)
                {
                    Debug.LogWarning($"[Ulink] Failed to create file for {key}: {e}.");
                    continue;
                }

                anyChanged = true;
            }

            if (anyChanged)
            {
                AssetDatabase.Refresh();
            }
        }

        private static string BuildFileContent(List<Type> types)
        {
            string manifest = string.Join("|", types.Select(type => type.FullName));
            string manifestHash = HashingUtility.HashString(manifest) ?? "0";

            var builder = new System.Text.StringBuilder();
            builder.AppendLine("// Auto-generated by Ulink. Do not modify this file.");
            builder.AppendLine($"// TemplateVersion: {TemplateVersion}");
            builder.AppendLine($"// ManifestHash: {manifestHash}");
            builder.AppendLine("#nullable enable");
            builder.AppendLine(GenerateUsing());
            builder.AppendLine();

            foreach (var type in types)
            {
                string ns = type.Namespace ?? string.Empty;
                string className = type.Name;
                builder.AppendLine(GenerateClass(className, ns));
            }

            return builder.ToString().Replace("\r\n", "\n");
        }

        private static string GenerateUsing()
        {
            return @"
using System;
using Ulink.Runtime;
using UnityEngine;
using UnityEngine.UIElements;";
        }

        private static string GenerateClass(string className, string? namespaceName)
        {
            return $@"{(string.IsNullOrEmpty(namespaceName) ? string.Empty : $"namespace {namespaceName}\n{{")}
    public partial class {className} 
    {{
        private IUIController? _controller;

        private ControllerType _controllerType;

        [UxmlAttribute]
        private ControllerType ControllerType
        {{
            get => _controllerType;
            set
            {{
                if (value.Type == null)
                {{
                    _controller = null;
                    _controllerType = ControllerType.Empty;
                    return;
                }}

                 try
                {{
                    _controllerType = value;
                    _controller = Activator.CreateInstance(_controllerType.Type!) as IUIController;
                    _controller?.Initialize(this);
                }}
                catch (Exception e)
                {{
                    _controller = null;
                    _controllerType = ControllerType.Empty;
                    Debug.LogWarning($""Failed to initialize Ulink Controller: {{e}}"");
                }}
            }}
        }}
    }}
{(string.IsNullOrEmpty(namespaceName) ? string.Empty : "}")}
";
        }

        /// <summary>
        /// Finds the root for the generated files
        /// </summary>
        /// <param name="scriptPath"></param>
        /// <returns></returns>
        private static string GetAssemblyRoot(string scriptPath)
        {
            string? directory = Path.GetDirectoryName(scriptPath);
            while (!string.IsNullOrEmpty(directory) && directory != AssetsPath)
            {
                if (Directory.GetFiles(directory, "*.asmdef").Length > 0)
                {
                    return directory;
                }

                directory = Path.GetDirectoryName(directory);
            }

            return AssetsPath;
        }

        private static bool HasBaseClass(Type type, HashSet<Type> options)
        {
            var baseClass = type.BaseType;
            while (baseClass != null && baseClass != typeof(object) && baseClass != typeof(VisualElement))
            {
                if (options.Contains(baseClass))
                {
                    return true;
                }

                baseClass = baseClass.BaseType;
            }

            return false;
        }

        private static string? FindScriptAssetPath(Type type)
        {
            foreach (var script in MonoImporter.GetAllRuntimeMonoScripts())
            {
                if (script.GetClass() == type)
                    return AssetDatabase.GetAssetPath(script);
            }

            string? asmName = type.Assembly.GetName().Name;
            var asm = CompilationPipeline.GetAssemblies()
                .FirstOrDefault(a => a.name == asmName);

            if (asm == null)
            {
                return null;
            }

            string typeName = Regex.Escape(type.Name);
            bool hasNs = !string.IsNullOrEmpty(type.Namespace);
            string? ns = hasNs ? Regex.Escape(type.Namespace!) : null;

            var classPattern = $@"\b(partial\s+)?class\s+{typeName}\b";
            string nsScoped = hasNs
                ? $@"\bnamespace\s+{ns}\b[\s\S]*?{{[\s\S]*?{classPattern}"
                : classPattern;

            var re = new Regex(nsScoped, RegexOptions.Multiline);

            foreach (string? sourcePath in asm.sourceFiles)
            {
                try
                {
                    string text = File.ReadAllText(sourcePath);
                    if (re.IsMatch(text))
                        return sourcePath.Replace('\\', '/');
                }
                catch
                {
                    // Ignore
                }
            }

            string[]? guids = AssetDatabase.FindAssets($"t:MonoScript {type.Name}");
            foreach (string guid in guids)
            {
                string? path = AssetDatabase.GUIDToAssetPath(guid);
                try
                {
                    string text = File.ReadAllText(path);
                    if (re.IsMatch(text))
                    {
                        return path;
                    }
                }
                catch
                {
                    // Ignore
                }
            }

            return null;
        }
    }
}